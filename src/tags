!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AF_BAD_FILEFMT	wiener_af.h	/^  AF_BAD_FILEFMT$/;"	e	enum:__anon5
AF_BAD_LSEEK	wiener_af.h	/^  AF_BAD_LSEEK,$/;"	e	enum:__anon5
AF_BAD_MALLOC	wiener_af.h	/^  AF_BAD_MALLOC,$/;"	e	enum:__anon5
AF_BAD_OPEN	wiener_af.h	/^  AF_BAD_OPEN,$/;"	e	enum:__anon5
AF_BAD_READ	wiener_af.h	/^  AF_BAD_READ,$/;"	e	enum:__anon5
AF_BAD_WRITE	wiener_af.h	/^  AF_BAD_WRITE,$/;"	e	enum:__anon5
AF_BYTEORDER_BIGENDIAN	wiener_af.h	/^  AF_BYTEORDER_BIGENDIAN = 501,$/;"	e	enum:__anon2
AF_BYTEORDER_LITTLEENDIAN	wiener_af.h	/^  AF_BYTEORDER_LITTLEENDIAN = 502$/;"	e	enum:__anon2
AF_DEFAULT_TRACK	wiener_af.h	/^  AF_DEFAULT_TRACK = 1001$/;"	e	enum:__anon1
AF_FILE_AIFF	wiener_af.h	/^  AF_FILE_AIFF = 2,$/;"	e	enum:__anon3
AF_FILE_AIFFC	wiener_af.h	/^  AF_FILE_AIFFC = 1,$/;"	e	enum:__anon3
AF_FILE_NEXTSND	wiener_af.h	/^  AF_FILE_NEXTSND = 3,$/;"	e	enum:__anon3
AF_FILE_RAWDATA	wiener_af.h	/^  AF_FILE_RAWDATA = 0,$/;"	e	enum:__anon3
AF_FILE_UNKNOWN	wiener_af.h	/^  AF_FILE_UNKNOWN = -1,$/;"	e	enum:__anon3
AF_FILE_WAVE	wiener_af.h	/^  AF_FILE_WAVE = 4$/;"	e	enum:__anon3
AF_NULL_FILEHANDLE	wiener_af.h	35;"	d
AF_NULL_FILESETUP	wiener_af.h	34;"	d
AF_RDONLY	wiener_af.c	/^  AF_RDONLY,$/;"	e	enum:openmode	file:
AF_SAMPFMT_DOUBLE	wiener_af.h	/^  AF_SAMPFMT_DOUBLE = 404 \/* 64-bit IEEE double-precision floating-point *\/$/;"	e	enum:__anon4
AF_SAMPFMT_FLOAT	wiener_af.h	/^  AF_SAMPFMT_FLOAT = 403, \/* 32-bit IEEE floating-point *\/$/;"	e	enum:__anon4
AF_SAMPFMT_TWOSCOMP	wiener_af.h	/^  AF_SAMPFMT_TWOSCOMP = 401, \/* linear two's complement *\/$/;"	e	enum:__anon4
AF_SAMPFMT_UNSIGNED	wiener_af.h	/^  AF_SAMPFMT_UNSIGNED = 402, \/* unsigned integer *\/$/;"	e	enum:__anon4
AF_WRONLY	wiener_af.c	/^  AF_WRONLY$/;"	e	enum:openmode	file:
AFerrfunc	wiener_af.h	/^typedef void (*AFerrfunc)(long, const char *);$/;"	t
AFfilehandle	wiener_af.h	/^typedef struct _AFfilehandle *AFfilehandle;$/;"	t	typeref:struct:_AFfilehandle
AFfileoffset	wiener_af.h	/^typedef off_t AFfileoffset;$/;"	t
AFfilesetup	wiener_af.h	/^typedef struct _AFfilesetup *AFfilesetup;$/;"	t	typeref:struct:_AFfilesetup
AFframecount	wiener_af.h	/^typedef off_t AFframecount;$/;"	t
AMPTODBFS	common.h	109;"	d
CLIPPING_WARN_THRESH	adjust.c	78;"	d	file:
DBFSTOAMP	common.h	111;"	d
DBTOFRAC	common.h	112;"	d
DEBUG	volume.c	65;"	d	file:
ELIDE_CODE	getopt.c	58;"	d	file:
ELIDE_CODE	getopt1.c	50;"	d	file:
EPSILON	common.h	105;"	d
FALSE	common.h	88;"	d
FRACTODB	common.h	110;"	d
GETOPT_INTERFACE_VERSION	getopt.c	54;"	d	file:
GETOPT_INTERFACE_VERSION	getopt1.c	46;"	d	file:
MAX	common.h	82;"	d
MIN	common.h	79;"	d
MIN	riff.c	87;"	d	file:
MPEG_BUFSZ	mpegvolume.c	71;"	d	file:
M_PI	mktestwav.c	72;"	d	file:
NONOPTION_P	getopt.c	542;"	d	file:
NULL	getopt1.c	64;"	d	file:
N_	adjust.c	73;"	d	file:
N_	mpegadjust.c	56;"	d	file:
N_	mpegvolume.c	58;"	d	file:
N_	normalize.c	78;"	d	file:
N_	riff.c	78;"	d	file:
N_	volume.c	61;"	d	file:
N_	wiener_af.c	76;"	d	file:
OPT_CLIPPING	normalize.c	/^    OPT_CLIPPING     = 0x101,$/;"	e	enum:__anon8	file:
OPT_FRACTIONS	normalize.c	/^    OPT_FRACTIONS    = 0x103,$/;"	e	enum:__anon8	file:
OPT_FRONTEND	normalize.c	/^    OPT_FRONTEND     = 0x108,$/;"	e	enum:__anon8	file:
OPT_ID3_COMPAT	normalize.c	/^    OPT_ID3_COMPAT   = 0x104,$/;"	e	enum:__anon8	file:
OPT_ID3_UNSYNC	normalize.c	/^    OPT_ID3_UNSYNC   = 0x105,$/;"	e	enum:__anon8	file:
OPT_NO_PROGRESS	normalize.c	/^    OPT_NO_PROGRESS  = 0x106,$/;"	e	enum:__anon8	file:
OPT_PEAK	normalize.c	/^    OPT_PEAK         = 0x102,$/;"	e	enum:__anon8	file:
OPT_QUERY	normalize.c	/^    OPT_QUERY        = 0x107,$/;"	e	enum:__anon8	file:
O_BINARY	common.h	100;"	d
O_BINARY	riff.c	83;"	d	file:
O_BINARY	wiener_af.c	79;"	d	file:
PERMUTE	getopt.c	/^  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER$/;"	e	enum:__anon6	file:
REQUIRE_ORDER	getopt.c	/^  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER$/;"	e	enum:__anon6	file:
RETURN_IN_ORDER	getopt.c	/^  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER$/;"	e	enum:__anon6	file:
RIFFID_JUNK	riff.h	74;"	d
RIFFID_JUNK	riff.h	78;"	d
RIFFID_LIST	riff.h	73;"	d
RIFFID_LIST	riff.h	77;"	d
RIFFID_RIFF	riff.h	72;"	d
RIFFID_RIFF	riff.h	76;"	d
RIFF_RDONLY	riff.h	82;"	d
RIFF_RDWR	riff.h	84;"	d
RIFF_SRCH_FLAT	riff.h	88;"	d
RIFF_SRCH_OFF	riff.h	87;"	d
RIFF_SRCH_RECURSE	riff.h	89;"	d
RIFF_WRONLY	riff.h	83;"	d
ROUND	common.h	85;"	d
SLASH_CHAR	common.h	94;"	d
SLASH_CHAR	common.h	96;"	d
SQRT2_2	mktestwav.c	76;"	d	file:
SWAP_FLAGS	getopt.c	284;"	d	file:
SWAP_FLAGS	getopt.c	292;"	d	file:
TRUE	common.h	91;"	d
USE_TEMPFILE	adjust.c	82;"	d	file:
VERBOSE_DEBUG	common.h	/^  VERBOSE_DEBUG    = 3$/;"	e	enum:verbose_t
VERBOSE_INFO	common.h	/^  VERBOSE_INFO     = 2,$/;"	e	enum:verbose_t
VERBOSE_PROGRESS	common.h	/^  VERBOSE_PROGRESS = 1,$/;"	e	enum:verbose_t
VERBOSE_QUIET	common.h	/^  VERBOSE_QUIET    = 0,$/;"	e	enum:verbose_t
_	adjust.c	68;"	d	file:
_	adjust.c	71;"	d	file:
_	getopt.c	92;"	d	file:
_	getopt.c	94;"	d	file:
_	mpegadjust.c	51;"	d	file:
_	mpegadjust.c	54;"	d	file:
_	mpegvolume.c	53;"	d	file:
_	mpegvolume.c	56;"	d	file:
_	normalize.c	70;"	d	file:
_	normalize.c	76;"	d	file:
_	riff.c	73;"	d	file:
_	riff.c	76;"	d	file:
_	volume.c	56;"	d	file:
_	volume.c	59;"	d	file:
_	wiener_af.c	71;"	d	file:
_	wiener_af.c	74;"	d	file:
_AFfilehandle	wiener_af.c	/^struct _AFfilehandle$/;"	s	file:
_AFfilesetup	wiener_af.c	/^struct _AFfilesetup$/;"	s	file:
_COMMON_H_	common.h	19;"	d
_GETOPT_H	getopt.h	21;"	d
_NO_PROTO	getopt.c	27;"	d	file:
_POSIX_C_SOURCE	adjust.c	18;"	d	file:
_POSIX_C_SOURCE	common.h	21;"	d
_POSIX_C_SOURCE	mktestwav.c	18;"	d	file:
_POSIX_C_SOURCE	mpegadjust.c	18;"	d	file:
_POSIX_C_SOURCE	mpegvolume.c	20;"	d	file:
_POSIX_C_SOURCE	normalize.c	18;"	d	file:
_POSIX_C_SOURCE	riff.c	18;"	d	file:
_POSIX_C_SOURCE	volume.c	18;"	d	file:
_POSIX_C_SOURCE	wiener_af.c	23;"	d	file:
_RIFF_H_	riff.h	19;"	d
_WIENER_AF_H_	wiener_af.h	24;"	d
__getopt_initialized	getopt.c	/^int __getopt_initialized = 0;$/;"	v
_afGetFrameSize	wiener_af.c	/^_afGetFrameSize(AFfilehandle fh, int track, int expand3to4)$/;"	f	file:
_af_err_func	wiener_af.c	/^static AFerrfunc _af_err_func = NULL;$/;"	v	file:
_do_apply_gain	adjust.c	/^static int _do_apply_gain(int read_fd, int write_fd, char *filename, double gain, struct signal_info *si)$/;"	f	file:
_getopt_initialize	getopt.c	/^_getopt_initialize (argc, argv, optstring)$/;"	f	file:
_getopt_internal	getopt.c	/^_getopt_internal (argc, argv, optstring, longopts, longind, long_only)$/;"	f
_int_to_buffer_lendian	riff.c	/^static void _int_to_buffer_lendian(unsigned char *buf, unsigned int x) \/* converts the integer x to a 4-byte little-endian array *\/$/;"	f	file:
_read_chunk_start	riff.c	/^static int _read_chunk_start(riff_t riff, riff_chunk_t *chnk)$/;"	f	file:
_riff_chunk_stack_t	riff.c	/^struct _riff_chunk_stack_t {$/;"	s	file:
_riff_chunk_t	riff.h	/^typedef struct _riff_chunk_t$/;"	s
_riff_t	riff.c	/^struct _riff_t {$/;"	s	file:
_riff_walk	riff.c	/^static int _riff_walk(riff_t riff, riff_chunk_t *par_chnk, int depth)$/;"	f	file:
_stack_pop	riff.c	/^static void _stack_pop(riff_chunk_stack_t *stack)$/;"	f	file:
_stack_push	riff.c	/^static int _stack_push(riff_chunk_stack_t *stack, long start, long end)$/;"	f	file:
adjust_id3	mpegadjust.c	/^adjust_id3(char *fname, double gain)$/;"	f	file:
adjust_thresh	normalize.c	/^double adjust_thresh = 0.125; \/* don't adjust less than this many dB *\/$/;"	v
afCloseFile	wiener_af.c	/^afCloseFile(AFfilehandle fh)$/;"	f
afFreeFileSetup	wiener_af.c	/^afFreeFileSetup(AFfilesetup setup)$/;"	f
afGetByteOrder	wiener_af.c	/^afGetByteOrder(AFfilehandle fh, int track)$/;"	f
afGetChannels	wiener_af.c	/^afGetChannels(AFfilehandle fh, int track)$/;"	f
afGetFileFormat	wiener_af.c	/^afGetFileFormat(AFfilehandle fh, int *version)$/;"	f
afGetFrameCount	wiener_af.c	/^afGetFrameCount(AFfilehandle fh, int track)$/;"	f
afGetFrameSize	wiener_af.c	/^afGetFrameSize(AFfilehandle fh, int track, int expand3to4)$/;"	f
afGetRate	wiener_af.c	/^afGetRate(AFfilehandle fh, int track)$/;"	f
afGetSampleFormat	wiener_af.c	/^afGetSampleFormat(AFfilehandle fh, int track, int *sampfmt, int *sampwidth)$/;"	f
afGetTrackBytes	wiener_af.c	/^afGetTrackBytes(AFfilehandle fh, int track)$/;"	f
afInitByteOrder	wiener_af.c	/^afInitByteOrder(AFfilesetup setup, int track, int byte_order)$/;"	f
afInitChannels	wiener_af.c	/^afInitChannels(AFfilesetup setup, int track, int nchannels)$/;"	f
afInitFileFormat	wiener_af.c	/^afInitFileFormat(AFfilesetup setup, int format)$/;"	f
afInitRate	wiener_af.c	/^afInitRate(AFfilesetup setup, int track, double rate)$/;"	f
afInitSampleFormat	wiener_af.c	/^afInitSampleFormat(AFfilesetup setup, int track, int sample_format,$/;"	f
afNewFileSetup	wiener_af.c	/^afNewFileSetup(void)$/;"	f
afOpenFD	wiener_af.c	/^AFfilehandle afOpenFD(int fd, const char *mode, AFfilesetup setup)$/;"	f
afOpenFile	wiener_af.c	/^AFfilehandle afOpenFile(const char *filename, const char *mode, AFfilesetup setup)$/;"	f
afReadFrames	wiener_af.c	/^afReadFrames(AFfilehandle fh, int track, void *buffer, int frame_count)$/;"	f
afSetErrorHandler	wiener_af.c	/^afSetErrorHandler(AFerrfunc errorFunction)$/;"	f
afSetVirtualSampleFormat	wiener_af.c	/^afSetVirtualSampleFormat(AFfilehandle fh, int track,$/;"	f
afSyncFile	wiener_af.c	/^afSyncFile(AFfilehandle fh)$/;"	f
afWriteFrames	wiener_af.c	/^afWriteFrames(AFfilehandle fh, int track, void *buffer, int frame_count)$/;"	f
apply_gain	adjust.c	/^int apply_gain(char *filename, double gain, struct signal_info *si)$/;"	f
apply_gain_mp3	mpegadjust.c	/^apply_gain_mp3(char *filename, double gain, struct signal_info *si)$/;"	f
average_levels	normalize.c	/^double average_levels(struct signal_info *sis, int nlevels, double threshold)$/;"	f
avg_bytes_per_sec	mktestwav.c	/^  uint32_t avg_bytes_per_sec;       \/* For buffer estimation *\/$/;"	m	struct:wavfmt	file:
avg_bytes_per_sec	riff.c	/^    uint32_t avg_bytes_per_sec;       \/* For buffer estimation *\/$/;"	m	struct:wavfmt	file:
avg_bytes_per_sec	wiener_af.c	/^  uint32_t avg_bytes_per_sec;       \/* For buffer estimation *\/$/;"	m	struct:wavfmt	file:
basename	normalize.c	/^basename(char *path)$/;"	f
batch_mode	normalize.c	/^int batch_mode = FALSE;$/;"	v
batch_size	common.h	/^  off_t batch_size;    \/* sum of all file sizes, in kb *\/$/;"	m	struct:progress_struct
batch_start	common.h	/^  time_t batch_start;  \/* what time we started processing the batch *\/$/;"	m	struct:progress_struct
bits_per_sample	common.h	/^  int bits_per_sample;$/;"	m	struct:signal_info
bits_per_sample	mktestwav.c	/^  uint16_t bits_per_sample;         \/* Sample size *\/$/;"	m	struct:wavfmt	file:
bits_per_sample	riff.c	/^    uint16_t bits_per_sample;         \/* Sample size *\/$/;"	m	struct:wavfmt	file:
bits_per_sample	wiener_af.c	/^  uint16_t bits_per_sample;         \/* Sample size *\/$/;"	m	struct:wavfmt	file:
block_align	mktestwav.c	/^  uint16_t block_align;             \/* Data block size *\/$/;"	m	struct:wavfmt	file:
block_align	riff.c	/^    uint16_t block_align;             \/* Data block size *\/$/;"	m	struct:wavfmt	file:
block_align	wiener_af.c	/^  uint16_t block_align;             \/* Data block size *\/$/;"	m	struct:wavfmt	file:
bswap_16	common.h	35;"	d
bswap_16	mktestwav.c	64;"	d	file:
bswap_16	riff.c	65;"	d	file:
bswap_16	wiener_af.c	63;"	d	file:
bswap_32	common.h	37;"	d
bswap_32	mktestwav.c	66;"	d	file:
bswap_32	riff.c	67;"	d	file:
bswap_32	wiener_af.c	65;"	d	file:
buf	mpegvolume.c	/^  double *buf;$/;"	m	struct:__anon7	file:
buf	volume.c	/^  double *buf;$/;"	m	struct:__anon9	file:
buffer	mpegvolume.c	/^  unsigned char buffer[MPEG_BUFSZ + MAD_BUFFER_GUARD];$/;"	m	struct:decode_struct	file:
buflen	mpegvolume.c	/^  int buflen;  \/* elements allocated to buffer *\/$/;"	m	struct:__anon7	file:
buflen	mpegvolume.c	/^  int buflen;$/;"	m	struct:decode_struct	file:
buflen	volume.c	/^  int buflen;  \/* elements allocated to buffer: same as n? *\/$/;"	m	struct:__anon9	file:
byte_order	wiener_af.c	/^  int byte_order;$/;"	m	struct:_AFfilesetup	file:
bytes_per_sample	mpegvolume.c	74;"	d	file:
channels	common.h	/^  int channels;$/;"	m	struct:signal_info
channels	mktestwav.c	/^  uint16_t channels;                \/* Number of channels *\/$/;"	m	struct:wavfmt	file:
channels	riff.c	/^    uint16_t channels;                \/* Number of channels *\/$/;"	m	struct:wavfmt	file:
channels	wiener_af.c	/^  uint16_t channels;                \/* Number of channels *\/$/;"	m	struct:wavfmt	file:
compute_levels	normalize.c	/^void compute_levels(struct signal_info *sis, char **fnames, int nfiles)$/;"	f
const	getopt.c	40;"	d	file:
const	getopt1.c	32;"	d	file:
data	riff.h	/^  unsigned char *data;$/;"	m	struct:_riff_chunk_t
data_chnk	wiener_af.c	/^  riff_chunk_t data_chnk;$/;"	m	struct:_AFfilehandle	file:
datasmooth_t	mpegvolume.c	/^} datasmooth_t;$/;"	t	typeref:struct:__anon7	file:
datasmooth_t	volume.c	/^} datasmooth_t;$/;"	t	typeref:struct:__anon9	file:
decode_error	mpegvolume.c	/^decode_error(void *dat, struct mad_stream *ms, struct mad_frame *mf)$/;"	f	file:
decode_input	mpegvolume.c	/^decode_input(void *dat, struct mad_stream *ms)$/;"	f	file:
decode_output	mpegvolume.c	/^decode_output(void *dat, struct mad_header const *mh, struct mad_pcm *pcm)$/;"	f	file:
decode_struct	mpegvolume.c	/^struct decode_struct {$/;"	s	file:
do_apply_gain	normalize.c	/^int do_apply_gain = TRUE;$/;"	v
do_compute_levels	normalize.c	/^int do_compute_levels = TRUE;$/;"	v
do_print_only	normalize.c	/^int do_print_only = FALSE;$/;"	v
do_query	normalize.c	/^int do_query = FALSE;$/;"	v
end_off	riff.c	/^    long end_off;$/;"	m	struct:_riff_chunk_stack_t	file:
eof	mpegvolume.c	/^  int eof;$/;"	m	struct:decode_struct	file:
exchange	getopt.c	/^exchange (argv)$/;"	f	file:
file_off	riff.c	/^    long file_off; \/* current file offset *\/$/;"	m	struct:_riff_t	file:
file_offset	mpegvolume.c	/^  off_t file_offset;$/;"	m	struct:decode_struct	file:
file_size	common.h	/^  off_t file_size;$/;"	m	struct:signal_info
file_sizes	common.h	/^  off_t *file_sizes;   \/* sizes of each file, in kb *\/$/;"	m	struct:progress_struct
file_start	common.h	/^  time_t file_start;   \/* what time we started processing the file *\/$/;"	m	struct:progress_struct
filename	mpegvolume.c	/^  char *filename;$/;"	m	struct:decode_struct	file:
finished_size	common.h	/^  off_t finished_size; \/* sum of sizes of all completed files, in kb *\/$/;"	m	struct:progress_struct
first_nonopt	getopt.c	/^static int first_nonopt;$/;"	v	file:
flag	getopt.h	/^  int *flag;$/;"	m	struct:option
fmt	wiener_af.c	/^  struct wavfmt fmt;$/;"	m	struct:_AFfilehandle	typeref:struct:_AFfilehandle::wavfmt	file:
fmt_chnk	wiener_af.c	/^  riff_chunk_t fmt_chnk;$/;"	m	struct:_AFfilehandle	file:
format	wiener_af.c	/^  int format;$/;"	m	struct:_AFfilesetup	file:
format_tag	mktestwav.c	/^  uint16_t format_tag;              \/* Format category *\/$/;"	m	struct:wavfmt	file:
format_tag	riff.c	/^    uint16_t format_tag;              \/* Format category *\/$/;"	m	struct:wavfmt	file:
format_tag	wiener_af.c	/^  uint16_t format_tag;              \/* Format category *\/$/;"	m	struct:wavfmt	file:
fourcc_t	riff.h	/^typedef uint32_t fourcc_t;$/;"	t
fp	riff.c	/^    FILE *fp; \/* needed for stream writing *\/$/;"	m	struct:_riff_t	file:
fp	riff.h	/^  FILE *fp;$/;"	m	struct:_riff_chunk_t
frontend	normalize.c	/^int frontend = FALSE;$/;"	v
gain_in_decibels	normalize.c	/^int gain_in_decibels = FALSE;$/;"	v
get_sample	adjust.c	/^static inline long get_sample(unsigned char *pdata, int bytes_per_sample)$/;"	f	file:
get_sample	volume.c	/^static inline long get_sample(unsigned char *pdata, int bytes_per_sample)$/;"	f	file:
get_smoothed_data	mpegvolume.c	/^get_smoothed_data(datasmooth_t *s)$/;"	f	file:
get_smoothed_data	volume.c	/^static inline double get_smoothed_data(datasmooth_t *s)$/;"	f	file:
get_window_power	mpegvolume.c	/^get_window_power(struct decode_struct *ds)$/;"	f	file:
getopt	getopt.c	/^getopt (argc, argv, optstring)$/;"	f
getopt_long	getopt1.c	/^getopt_long (argc, argv, options, long_options, opt_index)$/;"	f
getopt_long_only	getopt1.c	/^getopt_long_only (argc, argv, options, long_options, opt_index)$/;"	f
getpid	getopt.c	84;"	d	file:
has_arg	getopt.h	/^  int has_arg;$/;"	m	struct:option
id	riff.h	/^  fourcc_t id;   \/* chunk id *\/$/;"	m	struct:_riff_chunk_t
id	riff.h	/^  fourcc_t id;$/;"	m	struct:_riff_chunk_t
id3_compat	normalize.c	/^int id3_compat = FALSE;$/;"	v
id3_unsync	normalize.c	/^int id3_unsync = FALSE;$/;"	v
in	mpegvolume.c	/^  FILE *in;$/;"	m	struct:decode_struct	file:
last_nonopt	getopt.c	/^static int last_nonopt;$/;"	v	file:
last_progress	mpegvolume.c	/^  float last_progress;$/;"	m	struct:decode_struct	file:
level	common.h	/^  double level;      \/* maximum sustained RMS amplitude *\/$/;"	m	struct:signal_info
limiter	adjust.c	/^static double limiter(double x)$/;"	f	file:
lmtr_lvl	normalize.c	/^double lmtr_lvl = 0.5;$/;"	v
main	getopt.c	/^main (argc, argv)$/;"	f
main	getopt1.c	/^main (argc, argv)$/;"	f
main	mktestwav.c	/^main(int argc, char *argv[])$/;"	f
main	normalize.c	/^int main(int argc, char *argv[])$/;"	f
main	riff.c	/^int main(int argc, char *argv[])$/;"	f
max_sample	common.h	/^  long max_sample;   \/* maximum sample value *\/$/;"	m	struct:signal_info
maxpow	mpegvolume.c	/^  double maxpow;$/;"	m	struct:decode_struct	file:
memcpy	adjust.c	38;"	d	file:
memcpy	mpegadjust.c	38;"	d	file:
memcpy	mpegvolume.c	40;"	d	file:
memcpy	normalize.c	39;"	d	file:
memcpy	volume.c	38;"	d	file:
memcpy	wiener_af.c	43;"	d	file:
memmove	adjust.c	39;"	d	file:
memmove	mpegadjust.c	39;"	d	file:
memmove	mpegvolume.c	41;"	d	file:
memmove	normalize.c	40;"	d	file:
memmove	volume.c	39;"	d	file:
memmove	wiener_af.c	44;"	d	file:
min_sample	common.h	/^  long min_sample;   \/* minimum sample value *\/$/;"	m	struct:signal_info
mix_mode	normalize.c	/^int mix_mode = FALSE;$/;"	v
mode	riff.c	/^    int mode;$/;"	m	struct:_riff_t	file:
mode	wiener_af.c	/^  enum openmode mode;$/;"	m	struct:_AFfilehandle	typeref:enum:_AFfilehandle::openmode	file:
msg_stream	riff.c	/^    FILE *msg_stream;$/;"	m	struct:_riff_t	file:
my_index	getopt.c	/^my_index (str, chr)$/;"	f	file:
my_index	getopt.c	206;"	d	file:
n	mpegvolume.c	/^  int n;       \/* num of elements in buffer *\/$/;"	m	struct:__anon7	file:
n	volume.c	/^  int n;       \/* num of elements in buffer *\/$/;"	m	struct:__anon9	file:
name	getopt.h	/^  const char *name;$/;"	m	struct:option
nchannels	wiener_af.c	/^  int nchannels;$/;"	m	struct:_AFfilesetup	file:
next	riff.c	/^    struct _riff_chunk_stack_t *next;$/;"	m	struct:_riff_chunk_stack_t	typeref:struct:_riff_chunk_stack_t::_riff_chunk_stack_t	file:
nextchar	getopt.c	/^static char *nextchar;$/;"	v	file:
no_argument	getopt.h	95;"	d
nonoption_flags_len	getopt.c	/^static int nonoption_flags_len;$/;"	v	file:
nonoption_flags_max_len	getopt.c	/^static int nonoption_flags_max_len;$/;"	v	file:
offset	riff.h	/^  long offset;   \/* file offset (to beginning of data part) *\/$/;"	m	struct:_riff_chunk_t
offset	riff.h	/^  long offset;$/;"	m	struct:_riff_chunk_t
on_file	common.h	/^  int on_file;         \/* the index of the file we're working on *\/$/;"	m	struct:progress_struct
openmode	wiener_af.c	/^enum openmode$/;"	g	file:
optarg	getopt.c	/^char *optarg = NULL;$/;"	v
opterr	getopt.c	/^int opterr = 1;$/;"	v
optind	getopt.c	/^int optind = 1;$/;"	v
option	getopt.h	/^struct option$/;"	s
optional_argument	getopt.h	97;"	d
optopt	getopt.c	/^int optopt = '?';$/;"	v
ordering	getopt.c	/^} ordering;$/;"	v	typeref:enum:__anon6	file:
orig_index	common.h	/^  int orig_index;$/;"	m	struct:signal_info
original_argc	getopt.c	/^static int original_argc;$/;"	v	file:
original_argv	getopt.c	/^static char *const *original_argv;$/;"	v	file:
output_bitwidth	normalize.c	/^int output_bitwidth = 0;$/;"	v
peak	common.h	/^  double peak;       \/* peak amplitude *\/$/;"	m	struct:signal_info
posixly_correct	getopt.c	/^static char *posixly_correct;$/;"	v	file:
powsmooth	mpegvolume.c	/^  datasmooth_t powsmooth[2];$/;"	m	struct:decode_struct	file:
prefix_buf	mpegvolume.c	/^  char prefix_buf[18];$/;"	m	struct:decode_struct	file:
progname	mktestwav.c	/^char *progname;$/;"	v
progname	normalize.c	/^char *progname;$/;"	v
progname	riff.c	/^static char *progname;$/;"	v	file:
progress_callback	normalize.c	/^progress_callback(char *prefix, float fraction_completed)$/;"	f
progress_info	normalize.c	/^struct progress_struct progress_info;$/;"	v	typeref:struct:progress_struct
progress_struct	common.h	/^struct progress_struct$/;"	s
put_sample	adjust.c	/^static inline void put_sample(long sample, unsigned char *pdata, int bytes_per_sample)$/;"	f	file:
put_sample	mktestwav.c	/^put_sample(long sample, FILE *outf, int bytes_per_sample)$/;"	f	file:
rate	wiener_af.c	/^  double rate;$/;"	m	struct:_AFfilesetup	file:
ref	riff.c	/^    int ref;$/;"	m	struct:_riff_t	file:
ref	riff.h	/^  int ref;$/;"	m	struct:_riff_chunk_t
required_argument	getopt.h	96;"	d
riff	riff.h	/^  riff_t riff;   \/* riff the chunk is part of *\/$/;"	m	struct:_riff_chunk_t
riff	wiener_af.c	/^  riff_t riff;$/;"	m	struct:_AFfilehandle	file:
riff_ascend	riff.c	/^int riff_ascend(riff_t riff, riff_chunk_t *chnk) \/* return values: -1 means error; 0 means success *\/$/;"	f
riff_chunk_stack_t	riff.c	/^typedef struct _riff_chunk_stack_t *riff_chunk_stack_t;$/;"	t	typeref:struct:_riff_chunk_stack_t	file:
riff_chunk_stream	riff.c	/^FILE *riff_chunk_stream(riff_t riff, riff_chunk_t *chnk)$/;"	f
riff_chunk_t	riff.h	/^} riff_chunk_t;$/;"	t	typeref:struct:_riff_chunk_t
riff_close	riff.c	/^int riff_close(riff_t riff)$/;"	f
riff_create_chunk	riff.c	/^int riff_create_chunk(riff_t riff, riff_chunk_t *chnk) \/* not really about creating a chunk from zero; return values: -1 means error; 0 means success *\/$/;"	f
riff_descend	riff.c	/^int riff_descend(riff_t riff, riff_chunk_t *chnk, riff_chunk_t *par_chnk, int search)$/;"	f
riff_fdopen	riff.c	/^riff_t riff_fdopen(int fd, int mode)$/;"	f
riff_file	riff.h	/^  riff_t *riff_file;$/;"	m	struct:_riff_chunk_t
riff_fourcc_to_string	riff.h	101;"	d
riff_open	riff.c	/^riff_t riff_open(const char *fname, int mode)$/;"	f
riff_stream	riff.c	/^FILE *riff_stream(riff_t riff)$/;"	f
riff_string_to_fourcc	riff.h	102;"	d
riff_string_to_fourcc	riff.h	125;"	d
riff_t	riff.h	/^typedef struct _riff_t *riff_t;$/;"	t	typeref:struct:_riff_t
sample_format	wiener_af.c	/^  int sample_format;$/;"	m	struct:_AFfilesetup	file:
sample_width	wiener_af.c	/^  int sample_width;$/;"	m	struct:_AFfilesetup	file:
samplemax	mpegvolume.c	72;"	d	file:
samplemin	mpegvolume.c	73;"	d	file:
samples_per_sec	common.h	/^  unsigned int samples_per_sec;$/;"	m	struct:signal_info
samples_per_sec	mktestwav.c	/^  uint32_t samples_per_sec;         \/* Sampling rate *\/$/;"	m	struct:wavfmt	file:
samples_per_sec	riff.c	/^    uint32_t samples_per_sec;         \/* Sampling rate *\/$/;"	m	struct:wavfmt	file:
samples_per_sec	wiener_af.c	/^  uint32_t samples_per_sec;         \/* Sampling rate *\/$/;"	m	struct:wavfmt	file:
samples_so_far	mpegvolume.c	/^  unsigned int samples_so_far;$/;"	m	struct:decode_struct	file:
scale	mpegvolume.c	/^signed int scale(mad_fixed_t sample)$/;"	f	file:
show_progress	normalize.c	/^int show_progress = TRUE;$/;"	v
si	mpegvolume.c	/^  struct signal_info *si;$/;"	m	struct:decode_struct	typeref:struct:decode_struct::signal_info	file:
signal_info	common.h	/^struct signal_info$/;"	s
signal_max_power	volume.c	/^double signal_max_power(char *filename, struct signal_info *si)$/;"	f
signal_max_power_mp3	mpegvolume.c	/^signal_max_power_mp3(char *filename, struct signal_info *si)$/;"	f
size	riff.h	/^  uint32_t size; \/* chunk size, not including id and size fields *\/$/;"	m	struct:_riff_chunk_t
size	riff.h	/^  unsigned int size;$/;"	m	struct:_riff_chunk_t
stack	riff.c	/^    riff_chunk_stack_t stack;$/;"	m	struct:_riff_t	file:
start	mpegvolume.c	/^  int start;   \/* index of first element in buffer *\/$/;"	m	struct:__anon7	file:
start	volume.c	/^  int start;   \/* index of first element in buffer *\/$/;"	m	struct:__anon9	file:
start_off	riff.c	/^    long start_off;$/;"	m	struct:_riff_chunk_stack_t	file:
store_args_and_env	getopt.c	/^store_args_and_env (int argc, char *const *argv)$/;"	f	file:
strchr	adjust.c	34;"	d	file:
strchr	mktestwav.c	31;"	d	file:
strchr	mpegadjust.c	34;"	d	file:
strchr	mpegvolume.c	36;"	d	file:
strchr	normalize.c	35;"	d	file:
strchr	volume.c	34;"	d	file:
strchr	wiener_af.c	39;"	d	file:
strerror	riff.c	35;"	d	file:
strncaseeq	mktestwav.c	/^strncaseeq(const char *s1, const char *s2, size_t n)$/;"	f
strncaseeq	normalize.c	/^strncaseeq(const char *s1, const char *s2, size_t n)$/;"	f
strrchr	adjust.c	35;"	d	file:
strrchr	mktestwav.c	32;"	d	file:
strrchr	mpegadjust.c	35;"	d	file:
strrchr	mpegvolume.c	37;"	d	file:
strrchr	normalize.c	36;"	d	file:
strrchr	volume.c	35;"	d	file:
strrchr	wiener_af.c	40;"	d	file:
sums	mpegvolume.c	/^  double sums[2];$/;"	m	struct:decode_struct	file:
target	normalize.c	/^double target = 0.2511886431509580; \/* -12dBFS *\/$/;"	v
threshold	normalize.c	/^double threshold = -1.0; \/* in decibels *\/$/;"	v
top_chnk	wiener_af.c	/^  riff_chunk_t top_chnk;$/;"	m	struct:_AFfilehandle	file:
type	riff.h	/^  fourcc_t type; \/* form type; just for RIFF and LIST chunks *\/$/;"	m	struct:_riff_chunk_t
type	riff.h	/^  fourcc_t type; \/* just for RIFF and LIST chunks *\/$/;"	m	struct:_riff_chunk_t
usage	mktestwav.c	/^usage()$/;"	f
usage	normalize.c	/^void usage()$/;"	f
usage_short	normalize.c	/^void usage_short()$/;"	f
use_fractions	normalize.c	/^int use_fractions = FALSE;$/;"	v
use_limiter	normalize.c	/^int use_limiter = TRUE;$/;"	v
use_peak	normalize.c	/^int use_peak = FALSE;$/;"	v
val	getopt.h	/^  int val;$/;"	m	struct:option
verbose	normalize.c	/^int verbose = VERBOSE_PROGRESS;$/;"	v
verbose_t	common.h	/^enum verbose_t$/;"	g
version	version.c	/^char version[] = VERSION;$/;"	v
wavfmt	mktestwav.c	/^struct wavfmt {$/;"	s	file:
wavfmt	riff.c	/^struct wavfmt$/;"	s	file:
wavfmt	wiener_af.c	/^struct wavfmt$/;"	s	file:
windowsz	mpegvolume.c	/^  unsigned int windowsz;$/;"	m	struct:decode_struct	file:
write	riff.h	/^  int write;     \/* are we writing this chunk? *\/$/;"	m	struct:_riff_chunk_t
xmalloc	normalize.c	/^xmalloc(size_t size)$/;"	f
xmkstemp	adjust.c	/^int xmkstemp(char *template)$/;"	f
xrename	adjust.c	/^int xrename(const char *oldpath, const char *newpath)$/;"	f
